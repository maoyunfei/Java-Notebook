在Java运行时区域中，程序计数器、虚拟机栈、本地方法栈3个区域随线程的而生，随线程而灭，因此这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要多考虑回收的问题，因此方法结束或者线程结束时，内存自然就跟随着回收了。

而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配都是动态的，垃圾收集器所关注的是这部分内存。

## 1、判断对象是否“存活”

### 1.1 引用计数法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。

引用计数法的实现简单，判定效率也高，但是主流的Java虚拟机里面没有选用其来管理内存，最主要原因是**它很难解决对象之间相互循环引用的问题。**

### 1.2 可达性分析算法
这个算法的基本思想就是通过一系列的“GC Roots”对象作为起始点，从这些节点开始向下搜索。搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时(从图论来说，从GC Roots到这个对象不可达)，则证明此对象是不可用的。

**在Java语言中，可作为GC Roots的对象包括下面几种：**

* 虚拟机栈(栈帧中的本地变量表)中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI(Native方法)引用的对象。