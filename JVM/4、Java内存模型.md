# Java内存模型

Java虚拟机规范中试图定义一种Java内存模型(Java Memory Model, JMM)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

## 主内存与工作内存

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。

**Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了该被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量**，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下：

<img src="https://github.com/maoyunfei/Java-Notebook/blob/master/JVM/images/JMM.jpg?raw=true"  width = "70%" height = "70%" align=center />

这里所讲的主内存、工作内存与Java内存区域中的Java堆、栈、方法区并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分数据。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

## 内存间的交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外)。

* **lock**(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* **unlock**(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* **read**(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
* **load**(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* **use**(使用)：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
* **assign**(赋值)：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* **store**(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
* **write**(写入)：作用于工作内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

## 对于volatile型变量的特殊规则

关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两个特性，第一是**保证此变量对所有线程的可见性**，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。**虽然volatile变量在各个线程中是一致的，但是Java里面的运算并非原子操作，所以volatile变量的运算在并发下不能保证安全性。**

由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性。

* 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
* 变量不需要与其他的状态变量共同参与不变约束。

使用volatile变量的第二个语义是**禁止指令重排序优化**。

### 选用volatile的意义

大多数场景下volatile的总开销要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。

## 对long和double型变量的特殊规则

Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据结构(long和double)，在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即**允许虚拟机实现选择可以不保证64位数据结构的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子协定**。

## 原子性、可见性与有序性

**原子性**：

**可见性**：

**有序性**：

## 先行发生原则

**程序次序规则**：

**管程锁定规则**：

**volatile变量规则**：

**线程启动规则**：

**线程终止规则**：

**线程中断规则**：

**对象终极规则**：

**传递性**：


